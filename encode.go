package yarnlock

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"regexp"
	"sort"
	"strings"

	"github.com/pkg/errors"
)

const _INDENT string = "  "

var unwantedChars = regexp.MustCompile(`[:\s\n\\",\[\]]`)
var startsWithNum = regexp.MustCompile(`^[0-9]`)
var startsWithNonAlpha = regexp.MustCompile(`^[^a-zA-Z]`)

func shouldWrapKey(str string) bool {
	byteS := []byte(str)
	return strings.Index(str, "true") == 0 ||
		strings.Index(str, "false") == 0 ||
		unwantedChars.Match(byteS) ||
		startsWithNum.Match(byteS) ||
		startsWithNonAlpha.Match(byteS)
}

// Possibly wrap a string if it would be an invalid key in a lockfile
func maybeWrap(str string) string {
	// yarn uses JSON.stringify to escape strings
	// we approximate this behavior using json.Encoder
	if shouldWrapKey(str) {
		var b bytes.Buffer
		encoder := json.NewEncoder(&b)
		// by default the json package escapes HTML which mangles < and >
		encoder.SetEscapeHTML(false)
		err := encoder.Encode(str)
		if err != nil {
			panic("Unexpected error wrapping key")
		}
		// when using json.Encoder adds a newline for readability
		return strings.TrimRight(b.String(), "\n")
	}
	return str
}

func eqMaps(x map[string]string, y map[string]string) bool {
	if len(x) != len(y) {
		return false
	}

	xKeys := make([]string, len(x))
	i := 0
	for key, xVal := range x {
		yVal, ok := y[key]
		if !ok || xVal != yVal {
			return false
		}
		xKeys[i] = key
	}

	return true
}

func eqEntries(x LockFileEntry, y LockFileEntry) bool {
	return x.Name == y.Name &&
		x.Version == y.Version &&
		x.UID == y.UID &&
		x.Resolved == y.Resolved &&
		x.Integrity == y.Integrity &&
		x.Registry == y.Registry &&
		eqMaps(x.Dependencies, y.Dependencies) &&
		eqMaps(x.OptionalDependencies, y.OptionalDependencies)
}

func (f *LockFile) writePreamble(w io.Writer) error {
	if _, err := io.WriteString(w, fmt.Sprintf("# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v%d\n\n", LockfileVersion)); err != nil {
		return errors.Wrap(err, "encode failed")
	}
	return nil
}

// Get a sorted list of keys
func (f *LockFile) keys() []string {
	var keys = make([]string, len(*f))
	i := 0
	for key, _ := range *f {
		keys[i] = key
		i++
	}

	sort.Stable(sort.StringSlice(keys))

	return keys
}

func (f *LockFileEntry) encodeEntry(indent string) string {
	lines := []string{}
	addLine := func(field, value string) []string {
		return append(lines, fmt.Sprintf("%s%s %s", indent, field, value))
	}
	if f.Name != "" {
		lines = addLine("name", maybeWrap(f.Name))
	}
	if f.Version != "" {
		lines = addLine("version", maybeWrap(f.Version))
	}
	if f.UID != "" {
		lines = addLine("uid", maybeWrap(f.UID))
	}
	if f.Resolved != "" {
		lines = addLine("resolved", maybeWrap(f.Resolved))
	}
	if f.Integrity != "" {
		lines = addLine("integrity", maybeWrap(f.Integrity))
	}
	if f.Registry != "" {
		lines = addLine("registry", maybeWrap(f.Registry))
	}

	if len(f.Dependencies) != 0 {
		lines = append(lines, encodeMap(f.Dependencies, "dependencies", indent)...)
	}
	if len(f.OptionalDependencies) != 0 {
		lines = append(lines, encodeMap(f.OptionalDependencies, "optionalDependencies", indent)...)
	}

	return strings.Join(lines, "\n")
}

func encodeMap(m map[string]string, name, indent string) []string {
	lines := []string{fmt.Sprintf("%s%s:", indent, name)}

	// sort keys
	mappedKeys := map[string]string{}
	keys := make([]string, len(m))
	i := 0
	for key := range m {
		newKey := maybeWrap(key)
		mappedKeys[newKey] = key
		keys[i] = newKey
		i++
	}

	sort.Stable(sort.StringSlice(keys))

	innerIndent := indent + _INDENT
	for _, key := range keys {
		originalKey := mappedKeys[key]
		val := maybeWrap(m[originalKey])
		lines = append(lines, fmt.Sprintf("%s%s %s", innerIndent, key, val))
	}

	return lines
}

// Encode the contents of the LockFile
func (f *LockFile) Encode(w io.Writer) error {
	if err := f.writePreamble(w); err != nil {
		return err
	}

	keys := f.keys()
	addedKeys := []string{}
	addedKeysContains := func(key string) bool {
		for _, val := range addedKeys {
			if key == val {
				return true
			}
		}
		return false
	}

	for i, key := range keys {
		entry, ok := (*f)[key]

		if !ok || addedKeysContains(key) {
			continue
		}

		valKeys := []string{key}

		j := i + 1
		for j < len(keys) {
			key := keys[j]
			val := (*f)[key]
			if eqEntries(val, entry) {
				valKeys = append(valKeys, key)
			}
			j++
		}

		// Keys must be sorted before they are wrapped
		sort.Stable(sort.StringSlice(valKeys))

		wrappedKeys := make([]string, len(valKeys))
		for i, key := range valKeys {
			wrappedKeys[i] = maybeWrap(key)
		}

		keyLine := strings.Join(wrappedKeys, ", ")
		entryString := entry.encodeEntry(_INDENT)

		addedKeys = append(addedKeys, valKeys...)
		if _, err := io.WriteString(w, fmt.Sprintf("\n%s:\n%s\n", keyLine, entryString)); err != nil {
			return errors.Wrap(err, "encode failed")
		}
	}

	return nil
}
